Object.defineProperty(exports,"__esModule",{value:!0});var e=require("crypto"),r=require("./crypto-8485f492.js"),o=require("./decoder.js"),t=require("./error.js"),n=require("./utils.js");require("ecdsa-sig-formatter");function i(e,r){return e===r}function a(e,r){const o=e[0].slice(0,2),n=r[0].slice(0,2);let i=!0;if("RS"===o||"PS"===o?i="RS"===n:"ES"!==o&&"Ed"!==o||(i=o===n),!i)throw new t.TokenError(t.TokenError.codes.invalidKey,`Invalid public key provided for algorithms ${e.join(", ")}.`)}function c(o,t){return"string"==typeof o&&(o=Buffer.from(o,"utf-8")),r.useNewCrypto&&(o=t?e.createSecretKey(o):e.createPublicKey(o)),o}function l(e){return Array.isArray(e)||(e=[e]),e.filter((e=>e)).map((e=>e&&"function"==typeof e.test?e:{test:i.bind(null,e)}))}function s(e){const o=parseInt(!0===e?1e3:e,10);return o>0?new r.lruCache(o):null}function u({cache:e,token:r,cacheTTL:o,payload:t,ignoreExpiration:i,ignoreNotBefore:a,maxAge:c,clockTimestamp:l,clockTolerance:s},u){if(!e)return u;const p=[u,0,0];t&&"number"==typeof t.iat&&(p[1]=a||"number"!=typeof t.nbf?0:1e3*t.nbf,i||("number"==typeof t.exp?p[2]=1e3*t.exp:c&&(p[2]=1e3*t.iat+c)));const d=(l||Date.now())+s+o;return p[2]=0===p[2]?d:Math.min(p[2],d),e.set(n.hashToken(r),p),u}function p(e,r,o,n){const i=o?`The ${r} claim must be a ${n} or an array of ${n}s.`:`The ${r} claim must be a ${n}.`;if(e.map((e=>typeof e)).some((e=>e!==n)))throw new t.TokenError(t.TokenError.codes.invalidClaimType,i)}function d(e,r,o,n){const i=n?`None of ${r} claim values are allowed.`:`The ${r} claim value is not allowed.`;if(!e.some((e=>o.some((r=>r.test(e))))))throw new t.TokenError(t.TokenError.codes.invalidClaimValue,i)}function f(e,r,o,n,i,a){const c=1e3*e+(r||0);if(!(n?o>=c:o<=c))throw new t.TokenError(t.TokenError.codes[i],`The token ${a} at ${new Date(c).toISOString()}.`)}function h(e,{input:o,header:n,payload:i,signature:a},{validators:c,allowedAlgorithms:l,checkTyp:s,clockTimestamp:u,clockTolerance:h}){const m=e instanceof Buffer?e.length:!!e;if(m&&!a)throw new t.TokenError(t.TokenError.codes.missingSignature,"The token signature is missing.");if(!m&&a)throw new t.TokenError(t.TokenError.codes.missingKey,"The key option is missing.");if(function(e,o,n,i,a){if(!a.includes(o.alg))throw new t.TokenError(t.TokenError.codes.invalidAlgorithm,"The token algorithm is invalid.");if(n&&!r.verifySignature(o.alg,i,e,n))throw new t.TokenError(t.TokenError.codes.invalidSignature,"The token signature is invalid.")}(o,n,a,e,l),s&&("string"!=typeof n.typ||s!==n.typ.toLowerCase().replace(/^application\//,"")))throw new t.TokenError(t.TokenError.codes.invalidType,"Invalid typ.");const T=(u||Date.now())+h;for(const e of c){const{type:r,claim:o,allowed:t,array:n,modifier:a,greater:c,errorCode:l,errorVerb:s}=e,u=i[o],h=Array.isArray(u),m=h?u:[u];o in i&&(p(m,o,n,"date"===r?"number":"string"),"date"===r?f(u,a,T,c,l,s):d(m,o,t,h))}}function m({key:e,allowedAlgorithms:o,complete:i,cacheTTL:l,checkTyp:s,clockTimestamp:p,clockTolerance:d,ignoreExpiration:f,ignoreNotBefore:m,maxAge:T,isAsync:y,validators:k,decode:g,cache:w},b,E){const[v,A]=y?n.ensurePromiseCallback(E):[],x={cache:w,token:b,cacheTTL:l,payload:void 0,ignoreExpiration:f,ignoreNotBefore:m,maxAge:T,clockTimestamp:p,clockTolerance:d};if(w){const[e,r,o]=w.get(n.hashToken(b))||[void 0,0,0],i=(p||Date.now())+d;if(void 0!==e&&(0===r||i>r)&&(0===o||i<=o))return function(e,r,o){if(e instanceof t.TokenError){if(!r)throw e;r(e)}else{if(!r)return e;r(null,e)}return o}(e,v,A)}let C;try{C=g(b)}catch(e){if(v)return v(e),A;throw e}const{header:S,payload:L,signature:N}=C;x.payload=L;const $={validators:k,allowedAlgorithms:o,checkTyp:s,clockTimestamp:p,clockTolerance:d};if(!v)try{return h(e,C,$),u(x,i?{header:S,payload:L,signature:N}:L)}catch(e){throw u(x,e)}return n.getAsyncKey(e,S,((e,n)=>{if(e)return v(u(x,t.TokenError.wrap(e,t.TokenError.codes.keyFetchingError,"Cannot fetch key.")));if("string"==typeof n)n=Buffer.from(n,"utf-8");else if(!(n instanceof Buffer))return v(u(x,new t.TokenError(t.TokenError.codes.keyFetchingError,"The key returned from the callback must be a string or a buffer containing a secret or a public key.")));try{const e=r.detectPublicKeyAlgorithms(n);$.allowedAlgorithms.length?a(o,e):$.allowedAlgorithms=e,h(n=c(n,e[0]===r.hsAlgorithms[0]),C,$)}catch(e){return v(u(x,e))}v(null,u(x,i?{header:S,payload:L,signature:N}:L))})),A}exports.createVerifier=function(e){let{key:n,algorithms:i,complete:u,cache:p,cacheTTL:d,checkTyp:f,clockTimestamp:h,clockTolerance:T,ignoreExpiration:y,ignoreNotBefore:k,maxAge:g,allowedJti:w,allowedAud:b,allowedIss:E,allowedSub:v,allowedNonce:A}={cacheTTL:6e5,...e};Array.isArray(i)||(i=[]);const x=typeof n;if("string"!==x&&"object"!==x&&"function"!==x)throw new t.TokenError(t.TokenError.codes.INVALID_OPTION,"The key option must be a string, a buffer or a function returning the algorithm secret or public key.");if(n&&"function"!==x){const e=r.detectPublicKeyAlgorithms(n);i.length?a(i,e):i=e,n=c(n,e[0]===r.hsAlgorithms[0])}if(h&&("number"!=typeof h||h<0))throw new t.TokenError(t.TokenError.codes.invalidOption,"The clockTimestamp option must be a positive number.");if(T&&("number"!=typeof T||T<0))throw new t.TokenError(t.TokenError.codes.invalidOption,"The clockTolerance option must be a positive number.");if(T=0,d&&("number"!=typeof d||d<0))throw new t.TokenError(t.TokenError.codes.invalidOption,"The cacheTTL option must be a positive number.");const C=[];k||C.push({type:"date",claim:"nbf",errorCode:"inactive",errorVerb:"will be active",greater:!0}),y||C.push({type:"date",claim:"exp",errorCode:"expired",errorVerb:"has expired"}),"number"==typeof g&&C.push({type:"date",claim:"iat",errorCode:"expired",errorVerb:"has expired",modifier:g}),w&&C.push({type:"string",claim:"jti",allowed:l(w)}),b&&C.push({type:"string",claim:"aud",allowed:l(b),array:!0}),E&&C.push({type:"string",claim:"iss",allowed:l(E)}),v&&C.push({type:"string",claim:"sub",allowed:l(v)}),A&&C.push({type:"string",claim:"nonce",allowed:l(A)});let S=null;f&&(S=f.toLowerCase().replace(/^application\//,""));const L={key:n,allowedAlgorithms:i,complete:u,cacheTTL:d,checkTyp:S,clockTimestamp:h,clockTolerance:T,ignoreExpiration:y,ignoreNotBefore:k,maxAge:g,isAsync:"function"===x,validators:C,decode:o.createDecoder({complete:!0}),cache:s(p)},N=m.bind(null,L);return N.cache=L.cache,N};
