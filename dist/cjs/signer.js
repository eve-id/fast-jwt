Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./error.js"),r=require("crypto"),o=require("./crypto-7c2eb296.js");require("ecdsa-sig-formatter");var t=require("./utils.js");const n=Array.from(new Set([...o.hsAlgorithms,...o.esAlgorithms,...o.rsaAlgorithms,...o.edAlgorithms,"none"])).join(", ");function i(r,o){const t=r.slice(0,2),n=o.slice(0,2);let i=!0;if("RS"===t||"PS"===t?i="RS"===n:"ES"!==t&&"Ed"!==t||(i=t===n),!i)throw new e.TokenError(e.TokenError.codes.invalidKey,`Invalid private key provided for algorithm ${r}.`)}function s(e,t){return"string"==typeof e&&(e=Buffer.from(e,"utf-8")),o.useNewCrypto&&(e="H"===t[0]?r.createSecretKey(e):r.createPrivateKey(e)),e}function a({key:r,algorithm:n,noTimestamp:a,mutatePayload:c,clockTimestamp:f,expiresIn:l,notBefore:u,kid:p,typ:d,isAsync:h,additionalHeader:m,fixedPayload:k},y,T){const[g,b]=h?t.ensurePromiseCallback(T):[];if("object"!=typeof y)throw new e.TokenError(e.TokenError.codes.invalidType,"The payload must be a object, a string or a buffer.");const E={alg:n,typ:d||"JWT",kid:p,...m};let w="";const v=1e3*y.iat||f||Date.now(),O={...y,...k,iat:a?void 0:Math.floor(v/1e3),exp:l?Math.floor((v+l)/1e3):void 0,nbf:u?Math.floor((v+u)/1e3):void 0};if(c&&Object.assign(y,O),w=Buffer.from(JSON.stringify(O),"utf-8").toString("base64").replace(o.base64UrlMatcher,o.base64UrlReplacer),!g){const e=Buffer.from(JSON.stringify(E),"utf-8").toString("base64").replace(o.base64UrlMatcher,o.base64UrlReplacer)+"."+w;return e+"."+("none"===n?"":o.createSignature(n,r,e))}return t.getAsyncKey(r,E,(r,t)=>{if(r){const o=e.TokenError.wrap(r,e.TokenError.codes.keyFetchingError,"Cannot fetch key.");return g(o)}if("string"==typeof t)t=Buffer.from(t,"utf-8");else if(!(t instanceof Buffer))return g(new e.TokenError(e.TokenError.codes.keyFetchingError,"The key returned from the callback must be a string or a buffer containing a secret or a private key."));let a;try{const e=o.detectPrivateKeyAlgorithm(t);n?i(n,e):E.alg=n=e,t=s(t,n);const r=Buffer.from(JSON.stringify(E),"utf-8").toString("base64").replace(o.base64UrlMatcher,o.base64UrlReplacer)+"."+w;a=r+"."+o.createSignature(n,t,r)}catch(e){return g(e)}g(null,a)}),b}exports.createSigner=function(r){let{key:t,algorithm:c,noTimestamp:f,mutatePayload:l,clockTimestamp:u,expiresIn:p,notBefore:d,jti:h,aud:m,iss:k,sub:y,nonce:T,kid:g,typ:b,header:E}={clockTimestamp:0,...r};if(c&&"none"!==c&&!o.hsAlgorithms.includes(c)&&!o.esAlgorithms.includes(c)&&!o.rsaAlgorithms.includes(c)&&!o.edAlgorithms.includes(c))throw new e.TokenError(e.TokenError.codes.invalidOption,`The algorithm option must be one of the following values: ${n}.`);const w=typeof t;if("none"===c){if(t)throw new e.TokenError(e.TokenError.codes.invalidOption,'The key option must not be provided when the algorithm option is "none".')}else if(!t||"string"!==w&&!(t instanceof Buffer)&&"function"!==w)throw new e.TokenError(e.TokenError.codes.invalidOption,"The key option must be a string, a buffer or a function returning the algorithm secret or private key.");if(t&&"function"!==w){const e=o.detectPrivateKeyAlgorithm(t);c?i(c,e):c=e,t=s(t,c)}if(p&&("number"!=typeof p||p<0))throw new e.TokenError(e.TokenError.codes.invalidOption,"The expiresIn option must be a positive number.");if(d&&("number"!=typeof d||d<0))throw new e.TokenError(e.TokenError.codes.invalidOption,"The notBefore option must be a positive number.");if(u&&("number"!=typeof u||u<0))throw new e.TokenError(e.TokenError.codes.invalidOption,"The clockTimestamp option must be a positive number.");if(h&&"string"!=typeof h)throw new e.TokenError(e.TokenError.codes.invalidOption,"The jti option must be a string.");if(m&&"string"!=typeof m&&!Array.isArray(m))throw new e.TokenError(e.TokenError.codes.invalidOption,"The aud option must be a string or an array of strings.");if(k&&"string"!=typeof k)throw new e.TokenError(e.TokenError.codes.invalidOption,"The iss option must be a string.");if(y&&"string"!=typeof y)throw new e.TokenError(e.TokenError.codes.invalidOption,"The sub option must be a string.");if(T&&"string"!=typeof T)throw new e.TokenError(e.TokenError.codes.invalidOption,"The nonce option must be a string.");if(g&&"string"!=typeof g)throw new e.TokenError(e.TokenError.codes.invalidOption,"The kid option must be a string.");if(E&&"object"!=typeof E)throw new e.TokenError(e.TokenError.codes.invalidOption,"The header option must be a object.");const v={jti:h,aud:m,iss:k,sub:y,nonce:T},O={key:t,algorithm:c,noTimestamp:f,mutatePayload:l,clockTimestamp:u,expiresIn:p,notBefore:d,kid:g,typ:b,isAsync:"function"===w,additionalHeader:E,fixedPayload:Object.keys(v).reduce((e,r)=>void 0!==v[r]?Object.assign(e,{[r]:v[r]}):e,{})};return a.bind(null,O)};
