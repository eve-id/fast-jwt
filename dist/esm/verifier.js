import{createSecretKey as e,createPublicKey as o}from"crypto";import{d as t,h as r,l as i,u as n,v as a}from"./crypto-cfa6fd38.js";import{createDecoder as c}from"./decoder.js";import{TokenError as l}from"./error.js";import{ensurePromiseCallback as s,hashToken as p,getAsyncKey as f}from"./utils.js";import"ecdsa-sig-formatter";function u(e,o){return e===o}function d(e,o){const t=e[0].slice(0,2),r=o[0].slice(0,2);let i=!0;if("RS"===t||"PS"===t?i="RS"===r:"ES"!==t&&"Ed"!==t||(i=t===r),!i)throw new l(l.codes.invalidKey,`Invalid public key provided for algorithms ${e.join(", ")}.`)}function m(t,r){return"string"==typeof t&&(t=Buffer.from(t,"utf-8")),n&&(t=r?e(t):o(t)),t}function h(e){return Array.isArray(e)||(e=[e]),e.filter((e=>e)).map((e=>e&&"function"==typeof e.test?e:{test:u.bind(null,e)}))}function y(e){const o=parseInt(!0===e?1e3:e,10);return o>0?new i(o):null}function g({cache:e,token:o,cacheTTL:t,payload:r,ignoreExpiration:i,ignoreNotBefore:n,maxAge:a,clockTimestamp:c,clockTolerance:l},s){if(!e)return s;const f=[s,0,0];r&&"number"==typeof r.iat&&(f[1]=n||"number"!=typeof r.nbf?0:1e3*r.nbf,i||("number"==typeof r.exp?f[2]=1e3*r.exp:a&&(f[2]=1e3*r.iat+a)));const u=(c||Date.now())+l+t;return f[2]=0===f[2]?u:Math.min(f[2],u),e.set(p(o),f),s}function w(e,o,t,r){const i=t?`The ${o} claim must be a ${r} or an array of ${r}s.`:`The ${o} claim must be a ${r}.`;if(e.map((e=>typeof e)).some((e=>e!==r)))throw new l(l.codes.invalidClaimType,i)}function T(e,o,t,r){const i=r?`None of ${o} claim values are allowed.`:`The ${o} claim value is not allowed.`;if(!e.some((e=>t.some((o=>o.test(e))))))throw new l(l.codes.invalidClaimValue,i)}function k(e,o,t,r,i,n){const a=1e3*e+(o||0);if(!(r?t>=a:t<=a))throw new l(l.codes[i],`The token ${n} at ${new Date(a).toISOString()}.`)}function b(e,{input:o,header:t,payload:r,signature:i},{validators:n,allowedAlgorithms:c,checkTyp:s,clockTimestamp:p,clockTolerance:f}){const u=e instanceof Buffer?e.length:!!e;if(u&&!i)throw new l(l.codes.missingSignature,"The token signature is missing.");if(!u&&i)throw new l(l.codes.missingKey,"The key option is missing.");if(function(e,o,t,r,i){if(!i.includes(o.alg))throw new l(l.codes.invalidAlgorithm,"The token algorithm is invalid.");if(t&&!a(o.alg,r,e,t))throw new l(l.codes.invalidSignature,"The token signature is invalid.")}(o,t,i,e,c),s&&("string"!=typeof t.typ||s!==t.typ.toLowerCase().replace(/^application\//,"")))throw new l(l.codes.invalidType,"Invalid typ.");const d=(p||Date.now())+f;for(const e of n){const{type:o,claim:t,allowed:i,array:n,modifier:a,greater:c,errorCode:l,errorVerb:s}=e,p=r[t],f=Array.isArray(p),u=f?p:[p];t in r&&(w(u,t,n,"date"===o?"number":"string"),"date"===o?k(p,a,d,c,l,s):T(u,t,i,f))}}function v({key:e,allowedAlgorithms:o,complete:i,cacheTTL:n,checkTyp:a,clockTimestamp:c,clockTolerance:u,ignoreExpiration:h,ignoreNotBefore:y,maxAge:w,isAsync:T,validators:k,decode:v,cache:A},x,L){const[$,B]=T?s(L):[],C={cache:A,token:x,cacheTTL:n,payload:void 0,ignoreExpiration:h,ignoreNotBefore:y,maxAge:w,clockTimestamp:c,clockTolerance:u};if(A){const[e,o,t]=A.get(p(x))||[void 0,0,0],r=(c||Date.now())+u;if(void 0!==e&&(0===o||r>o)&&(0===t||r<=t))return function(e,o,t){if(e instanceof l){if(!o)throw e;o(e)}else{if(!o)return e;o(null,e)}return t}(e,$,B)}let E;try{E=v(x)}catch(e){if($)return $(e),B;throw e}const{header:N,payload:S,signature:I}=E;C.payload=S;const j={validators:k,allowedAlgorithms:o,checkTyp:a,clockTimestamp:c,clockTolerance:u};if(!$)try{return b(e,E,j),g(C,i?{header:N,payload:S,signature:I}:S)}catch(e){throw g(C,e)}return f(e,N,((e,n)=>{if(e)return $(g(C,l.wrap(e,l.codes.keyFetchingError,"Cannot fetch key.")));if("string"==typeof n)n=Buffer.from(n,"utf-8");else if(!(n instanceof Buffer))return $(g(C,new l(l.codes.keyFetchingError,"The key returned from the callback must be a string or a buffer containing a secret or a public key.")));try{const e=t(n);j.allowedAlgorithms.length?d(o,e):j.allowedAlgorithms=e,b(n=m(n,e[0]===r[0]),E,j)}catch(e){return $(g(C,e))}$(null,g(C,i?{header:N,payload:S,signature:I}:S))})),B}function A(e){let{key:o,algorithms:i,complete:n,cache:a,cacheTTL:s,checkTyp:p,clockTimestamp:f,clockTolerance:u,ignoreExpiration:g,ignoreNotBefore:w,maxAge:T,allowedJti:k,allowedAud:b,allowedIss:A,allowedSub:x,allowedNonce:L}={cacheTTL:6e5,...e};Array.isArray(i)||(i=[]);const $=typeof o;if("string"!==$&&"object"!==$&&"function"!==$)throw new l(l.codes.INVALID_OPTION,"The key option must be a string, a buffer or a function returning the algorithm secret or public key.");if(o&&"function"!==$){const e=t(o);i.length?d(i,e):i=e,o=m(o,e[0]===r[0])}if(f&&("number"!=typeof f||f<0))throw new l(l.codes.invalidOption,"The clockTimestamp option must be a positive number.");if(u&&("number"!=typeof u||u<0))throw new l(l.codes.invalidOption,"The clockTolerance option must be a positive number.");if(u=0,s&&("number"!=typeof s||s<0))throw new l(l.codes.invalidOption,"The cacheTTL option must be a positive number.");const B=[];w||B.push({type:"date",claim:"nbf",errorCode:"inactive",errorVerb:"will be active",greater:!0}),g||B.push({type:"date",claim:"exp",errorCode:"expired",errorVerb:"has expired"}),"number"==typeof T&&B.push({type:"date",claim:"iat",errorCode:"expired",errorVerb:"has expired",modifier:T}),k&&B.push({type:"string",claim:"jti",allowed:h(k)}),b&&B.push({type:"string",claim:"aud",allowed:h(b),array:!0}),A&&B.push({type:"string",claim:"iss",allowed:h(A)}),x&&B.push({type:"string",claim:"sub",allowed:h(x)}),L&&B.push({type:"string",claim:"nonce",allowed:h(L)});let C=null;p&&(C=p.toLowerCase().replace(/^application\//,""));const E={key:o,allowedAlgorithms:i,complete:n,cacheTTL:s,checkTyp:C,clockTimestamp:f,clockTolerance:u,ignoreExpiration:g,ignoreNotBefore:w,maxAge:T,isAsync:"function"===$,validators:B,decode:c({complete:!0}),cache:y(a)},N=v.bind(null,E);return N.cache=E.cache,N}export{A as createVerifier};
