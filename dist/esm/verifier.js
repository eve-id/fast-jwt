import{TokenError as e}from"./error.js";import{createDecoder as o}from"./decoder.js";import{createSecretKey as t,createPublicKey as r}from"crypto";import{d as i,h as n,l as a,u as c,v as l}from"./crypto-56fbb56b.js";import"ecdsa-sig-formatter";import{ensurePromiseCallback as s,hashToken as p,getAsyncKey as f}from"./utils.js";function d(o,t){const r=o[0].slice(0,2),i=t[0].slice(0,2);let n=!0;if("RS"===r||"PS"===r?n="RS"===i:"ES"!==r&&"Ed"!==r||(n=r===i),!n)throw new e(e.codes.invalidKey,`Invalid public key provided for algorithms ${o.join(", ")}.`)}function m(e,o){return"string"==typeof e&&(e=Buffer.from(e,"utf-8")),c&&(e=o?t(e):r(e)),e}function u(e){return Array.isArray(e)||(e=[e]),e.map(e=>e&&"function"==typeof e.test?e:new RegExp(e.toString()))}function h(e){const o=parseInt(!0===e?1e3:e,10);return o>0?new a(o):null}function y({cache:e,token:o,cacheTTL:t,payload:r,ignoreExpiration:i,ignoreNotBefore:n,maxAge:a,clockTimestamp:c,clockTolerance:l},s){if(!e)return s;const f=[s,0,0];r&&"number"==typeof r.iat&&(f[1]=n||"number"!=typeof r.nbf?0:1e3*r.nbf,i||("number"==typeof r.exp?f[2]=1e3*r.exp:a&&(f[2]=1e3*r.iat+a)));const d=(c||Date.now())+l+t;return f[2]=0===f[2]?d:Math.min(f[2],d),e.set(p(o),f),s}function g(o,t,r,i){const n=r?`The ${t} claim must be a ${i} or an array of ${i}s.`:`The ${t} claim must be a ${i}.`;if(o.map(e=>typeof e).some(e=>e!==i))throw new e(e.codes.invalidClaimType,n)}function w(o,t,r,i){const n=i?`None of ${t} claim values is allowed.`:`The ${t} claim value is not allowed.`;if(!o.some(e=>r.some(o=>o.test(e))))throw new e(e.codes.invalidClaimValue,n)}function T(o,t,r,i,n,a){const c=1e3*o+(t||0);if(!(i?r>=c:r<=c))throw new e(e.codes[n],`The token ${a} at ${new Date(c).toISOString()}.`)}function k(o,{input:t,header:r,payload:i,signature:n},{validators:a,allowedAlgorithms:c,checkTyp:s,clockTimestamp:p,clockTolerance:f}){const d=o instanceof Buffer?o.length:!!o;if(d&&!n)throw new e(e.codes.missingSignature,"The token signature is missing.");if(!d&&n)throw new e(e.codes.missingKey,"The key option is missing.");if(function(o,t,r,i,n){if(!n.includes(t.alg))throw new e(e.codes.invalidAlgorithm,"The token algorithm is invalid.");if(r&&!l(t.alg,i,o,r))throw new e(e.codes.invalidSignature,"The token signature is invalid.")}(t,r,n,o,c),s&&("string"!=typeof r.typ||s!==r.typ.toLowerCase().replace(/^application\//,"")))throw new e(e.codes.invalidType,"Invalid typ.");const m=(p||Date.now())+f;for(const e of a){const{type:o,claim:t,allowed:r,array:n,modifier:a,greater:c,errorCode:l,errorVerb:s}=e,p=i[t],f=Array.isArray(p),d=f?p:[p];t in i&&(g(d,t,n,"date"===o?"number":"string"),"date"===o?T(p,a,m,c,l,s):w(d,t,r,f))}}function b({key:o,allowedAlgorithms:t,complete:r,cacheTTL:a,checkTyp:c,clockTimestamp:l,clockTolerance:u,ignoreExpiration:h,ignoreNotBefore:g,maxAge:w,isAsync:T,validators:b,decode:v,cache:A},x,E){const[L,S]=T?s(E):[],$={cache:A,token:x,cacheTTL:a,payload:void 0,ignoreExpiration:h,ignoreNotBefore:g,maxAge:w,clockTimestamp:l,clockTolerance:u};if(A){const[o,t,r]=A.get(p(x))||[void 0,0,0],i=(l||Date.now())+u;if(void 0!==o&&(0===t||i>t)&&(0===r||i<=r))return function(o,t,r){if(o instanceof e){if(!t)throw o;t(o)}else{if(!t)return o;t(null,o)}return r}(o,L,S)}let B;try{B=v(x)}catch(e){if(L)return L(e),S;throw e}const{header:C,payload:N,signature:I}=B;$.payload=N;const j={validators:b,allowedAlgorithms:t,checkTyp:c,clockTimestamp:l,clockTolerance:u};if(!L)try{return k(o,B,j),y($,r?{header:C,payload:N,signature:I}:N)}catch(e){throw y($,e)}return f(o,C,(o,a)=>{if(o)return L(y($,e.wrap(o,e.codes.keyFetchingError,"Cannot fetch key.")));if("string"==typeof a)a=Buffer.from(a,"utf-8");else if(!(a instanceof Buffer))return L(y($,new e(e.codes.keyFetchingError,"The key returned from the callback must be a string or a buffer containing a secret or a public key.")));try{const e=i(a);j.allowedAlgorithms.length?d(t,e):j.allowedAlgorithms=e,k(a=m(a,e[0]===n[0]),B,j)}catch(e){return L(y($,e))}L(null,y($,r?{header:C,payload:N,signature:I}:N))}),S}function v(t){let{key:r,algorithms:a,complete:c,cache:l,cacheTTL:s,checkTyp:p,clockTimestamp:f,clockTolerance:y,ignoreExpiration:g,ignoreNotBefore:w,maxAge:T,allowedJti:k,allowedAud:v,allowedIss:A,allowedSub:x,allowedNonce:E}={cacheTTL:6e5,...t};Array.isArray(a)||(a=[]);const L=typeof r;if("string"!==L&&"object"!==L&&"function"!==L)throw new e(e.codes.INVALID_OPTION,"The key option must be a string, a buffer or a function returning the algorithm secret or public key.");if(r&&"function"!==L){const e=i(r);a.length?d(a,e):a=e,r=m(r,e[0]===n[0])}if(f&&("number"!=typeof f||f<0))throw new e(e.codes.invalidOption,"The clockTimestamp option must be a positive number.");if(y&&("number"!=typeof y||y<0))throw new e(e.codes.invalidOption,"The clockTolerance option must be a positive number.");if(y=0,s&&("number"!=typeof s||s<0))throw new e(e.codes.invalidOption,"The cacheTTL option must be a positive number.");const S=[];w||S.push({type:"date",claim:"nbf",errorCode:"inactive",errorVerb:"will be active",greater:!0}),g||S.push({type:"date",claim:"exp",errorCode:"expired",errorVerb:"has expired"}),"number"==typeof T&&S.push({type:"date",claim:"iat",errorCode:"expired",errorVerb:"has expired",modifier:T}),k&&S.push({type:"string",claim:"jti",allowed:u(k)}),v&&S.push({type:"string",claim:"aud",allowed:u(v),array:!0}),A&&S.push({type:"string",claim:"iss",allowed:u(A)}),x&&S.push({type:"string",claim:"sub",allowed:u(x)}),E&&S.push({type:"string",claim:"nonce",allowed:u(E)});let $=null;p&&($=p.toLowerCase().replace(/^application\//,""));const B={key:r,allowedAlgorithms:a,complete:c,cacheTTL:s,checkTyp:$,clockTimestamp:f,clockTolerance:y,ignoreExpiration:g,ignoreNotBefore:w,maxAge:T,isAsync:"function"===L,validators:S,decode:o({complete:!0}),cache:h(l)},C=b.bind(null,B);return C.cache=B.cache,C}export{v as createVerifier};
