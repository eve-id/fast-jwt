import{TokenError as e}from"./error.js";import{createSecretKey as t,createPrivateKey as o}from"crypto";import{h as i,e as n,r,a as s,b as a,u as f,c,f as p,g as d}from"./crypto-56fbb56b.js";import"ecdsa-sig-formatter";import{ensurePromiseCallback as u,getAsyncKey as l}from"./utils.js";const m=Array.from(new Set([...i,...n,...r,...s,"none"])).join(", ");function h(t,o){const i=t.slice(0,2),n=o.slice(0,2);let r=!0;if("RS"===i||"PS"===i?r="RS"===n:"ES"!==i&&"Ed"!==i||(r=i===n),!r)throw new e(e.codes.invalidKey,`Invalid private key provided for algorithm ${t}.`)}function y(e,i){return"string"==typeof e&&(e=Buffer.from(e,"utf-8")),f&&(e="H"===i[0]?t(e):o(e)),e}function b({key:t,algorithm:o,noTimestamp:i,mutatePayload:n,clockTimestamp:r,expiresIn:s,notBefore:f,kid:m,isAsync:b,additionalHeader:g,fixedPayload:w},v,T){const[k,O]=b?u(T):[];if("object"!=typeof v)throw new e(e.codes.invalidType,"The payload must be a object, a string or a buffer.");const j={alg:o,typ:"JWT",kid:m,...g};let B="";const S=1e3*v.iat||r||Date.now(),x={...v,...w,iat:i?void 0:Math.floor(S/1e3),exp:s?Math.floor((S+s)/1e3):void 0,nbf:f?Math.floor((S+f)/1e3):void 0};if(n&&Object.assign(v,x),B=Buffer.from(JSON.stringify(x),"utf-8").toString("base64").replace(c,p),!k){const e=Buffer.from(JSON.stringify(j),"utf-8").toString("base64").replace(c,p)+"."+B;return e+"."+("none"===o?"":d(o,t,e))}return l(t,j,(t,i)=>{if(t){const o=e.wrap(t,e.codes.keyFetchingError,"Cannot fetch key.");return k(o)}if("string"==typeof i)i=Buffer.from(i,"utf-8");else if(!(i instanceof Buffer))return k(new e(e.codes.keyFetchingError,"The key returned from the callback must be a string or a buffer containing a secret or a private key."));let n;try{const e=a(i);o?h(o,e):j.alg=o=e,i=y(i,o);const t=Buffer.from(JSON.stringify(j),"utf-8").toString("base64").replace(c,p)+"."+B;n=t+"."+d(o,i,t)}catch(e){return k(e)}k(null,n)}),O}function g(t){let{key:o,algorithm:f,noTimestamp:c,mutatePayload:p,clockTimestamp:d,expiresIn:u,notBefore:l,jti:g,aud:w,iss:v,sub:T,nonce:k,kid:O,header:j}={clockTimestamp:0,...t};if(f&&"none"!==f&&!i.includes(f)&&!n.includes(f)&&!r.includes(f)&&!s.includes(f))throw new e(e.codes.invalidOption,`The algorithm option must be one of the following values: ${m}.`);const B=typeof o;if("none"===f){if(o)throw new e(e.codes.invalidOption,'The key option must not be provided when the algorithm option is "none".')}else if(!o||"string"!==B&&!(o instanceof Buffer)&&"function"!==B)throw new e(e.codes.invalidOption,"The key option must be a string, a buffer or a function returning the algorithm secret or private key.");if(o&&"function"!==B){const e=a(o);f?h(f,e):f=e,o=y(o,f)}if(u&&("number"!=typeof u||u<0))throw new e(e.codes.invalidOption,"The expiresIn option must be a positive number.");if(l&&("number"!=typeof l||l<0))throw new e(e.codes.invalidOption,"The notBefore option must be a positive number.");if(d&&("number"!=typeof d||d<0))throw new e(e.codes.invalidOption,"The clockTimestamp option must be a positive number.");if(g&&"string"!=typeof g)throw new e(e.codes.invalidOption,"The jti option must be a string.");if(w&&"string"!=typeof w&&!Array.isArray(w))throw new e(e.codes.invalidOption,"The aud option must be a string or an array of strings.");if(v&&"string"!=typeof v)throw new e(e.codes.invalidOption,"The iss option must be a string.");if(T&&"string"!=typeof T)throw new e(e.codes.invalidOption,"The sub option must be a string.");if(k&&"string"!=typeof k)throw new e(e.codes.invalidOption,"The nonce option must be a string.");if(O&&"string"!=typeof O)throw new e(e.codes.invalidOption,"The kid option must be a string.");if(j&&"object"!=typeof j)throw new e(e.codes.invalidOption,"The header option must be a object.");const S={jti:g,aud:w,iss:v,sub:T,nonce:k},x={key:o,algorithm:f,noTimestamp:c,mutatePayload:p,clockTimestamp:d,expiresIn:u,notBefore:l,kid:O,isAsync:"function"===B,additionalHeader:j,fixedPayload:Object.keys(S).reduce((e,t)=>void 0!==S[t]?Object.assign(e,{[t]:S[t]}):e,{})};return b.bind(null,x)}export{g as createSigner};
