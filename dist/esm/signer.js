import{h as e,e as t,r as o,a as i,b as n,u as r,c as s,f as a,g as f}from"./crypto-cfa6fd38.js";import{TokenError as c}from"./error.js";import{ensurePromiseCallback as p,getAsyncKey as d}from"./utils.js";import{createSecretKey as u,createPrivateKey as l}from"crypto";import"ecdsa-sig-formatter";const m=Array.from(new Set([...e,...t,...o,...i,"none"])).join(", ");function h(e,t){const o=e.slice(0,2),i=t.slice(0,2);let n=!0;if("RS"===o||"PS"===o?n="RS"===i:"ES"!==o&&"Ed"!==o||(n=o===i),!n)throw new c(c.codes.invalidKey,`Invalid private key provided for algorithm ${e}.`)}function y(e,t){return"string"==typeof e&&(e=Buffer.from(e,"utf-8")),r&&(e="H"===t[0]?u(e):l(e)),e}function g({key:e,algorithm:t,noTimestamp:o,mutatePayload:i,clockTimestamp:r,expiresIn:u,notBefore:l,kid:m,typ:g,isAsync:b,additionalHeader:w,fixedPayload:v},T,k){const[O,j]=b?p(k):[];if("object"!=typeof T)throw new c(c.codes.invalidType,"The payload must be an object.");if(T.exp&&(!Number.isInteger(T.exp)||T.exp<0))throw new c(c.codes.invalidClaimValue,"The exp claim must be a positive integer.");const x={alg:t,typ:g||"JWT",kid:m,...w};let B="";const S=1e3*T.iat||r||Date.now(),I={...T,...v,iat:o?void 0:Math.floor(S/1e3),exp:u?Math.floor((S+u)/1e3):T.exp||void 0,nbf:l?Math.floor((S+l)/1e3):void 0};if(i&&Object.assign(T,I),B=Buffer.from(JSON.stringify(I),"utf-8").toString("base64").replace(s,a),!O){const o=Buffer.from(JSON.stringify(x),"utf-8").toString("base64").replace(s,a)+"."+B;return o+"."+("none"===t?"":f(t,e,o))}return d(e,x,((e,o)=>{if(e){const t=c.wrap(e,c.codes.keyFetchingError,"Cannot fetch key.");return O(t)}if("string"==typeof o)o=Buffer.from(o,"utf-8");else if(!(o instanceof Buffer))return O(new c(c.codes.keyFetchingError,"The key returned from the callback must be a string or a buffer containing a secret or a private key."));let i;try{const e=n(o);t?h(t,e):x.alg=t=e,o=y(o,t);const r=Buffer.from(JSON.stringify(x),"utf-8").toString("base64").replace(s,a)+"."+B;i=r+"."+f(t,o,r)}catch(e){return O(e)}O(null,i)})),j}function b(r){let{key:s,algorithm:a,noTimestamp:f,mutatePayload:p,clockTimestamp:d,expiresIn:u,notBefore:l,jti:b,aud:w,iss:v,sub:T,nonce:k,kid:O,typ:j,header:x}={clockTimestamp:0,...r};if(a&&"none"!==a&&!e.includes(a)&&!t.includes(a)&&!o.includes(a)&&!i.includes(a))throw new c(c.codes.invalidOption,`The algorithm option must be one of the following values: ${m}.`);const B=typeof s;if("none"===a){if(s)throw new c(c.codes.invalidOption,'The key option must not be provided when the algorithm option is "none".')}else if(!s||"string"!==B&&!(s instanceof Buffer)&&"function"!==B)throw new c(c.codes.invalidOption,"The key option must be a string, a buffer or a function returning the algorithm secret or private key.");if(s&&"function"!==B){const e=n(s);a?h(a,e):a=e,s=y(s,a)}if(u&&("number"!=typeof u||u<0))throw new c(c.codes.invalidOption,"The expiresIn option must be a positive number.");if(l&&("number"!=typeof l||l<0))throw new c(c.codes.invalidOption,"The notBefore option must be a positive number.");if(d&&("number"!=typeof d||d<0))throw new c(c.codes.invalidOption,"The clockTimestamp option must be a positive number.");if(b&&"string"!=typeof b)throw new c(c.codes.invalidOption,"The jti option must be a string.");if(w&&"string"!=typeof w&&!Array.isArray(w))throw new c(c.codes.invalidOption,"The aud option must be a string or an array of strings.");if(v&&"string"!=typeof v)throw new c(c.codes.invalidOption,"The iss option must be a string.");if(T&&"string"!=typeof T)throw new c(c.codes.invalidOption,"The sub option must be a string.");if(k&&"string"!=typeof k)throw new c(c.codes.invalidOption,"The nonce option must be a string.");if(O&&"string"!=typeof O)throw new c(c.codes.invalidOption,"The kid option must be a string.");if(x&&"object"!=typeof x)throw new c(c.codes.invalidOption,"The header option must be a object.");const S={jti:b,aud:w,iss:v,sub:T,nonce:k},I={key:s,algorithm:a,noTimestamp:f,mutatePayload:p,clockTimestamp:d,expiresIn:u,notBefore:l,kid:O,typ:j,isAsync:"function"===B,additionalHeader:x,fixedPayload:Object.keys(S).reduce(((e,t)=>void 0!==S[t]?Object.assign(e,{[t]:S[t]}):e),{})};return g.bind(null,I)}export{b as createSigner};
