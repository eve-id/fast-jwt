import{TokenError as e}from"./error.js";import{createSecretKey as t,createPrivateKey as o}from"crypto";import{h as i,e as n,r,a as s,b as a,u as f,c,f as p,g as d}from"./crypto-56fbb56b.js";import"ecdsa-sig-formatter";import{ensurePromiseCallback as u,getAsyncKey as l}from"./utils.js";const m=Array.from(new Set([...i,...n,...r,...s,"none"])).join(", ");function h(t,o){const i=t.slice(0,2),n=o.slice(0,2);let r=!0;if("RS"===i||"PS"===i?r="RS"===n:"ES"!==i&&"Ed"!==i||(r=i===n),!r)throw new e(e.codes.invalidKey,`Invalid private key provided for algorithm ${t}.`)}function y(e,i){return"string"==typeof e&&(e=Buffer.from(e,"utf-8")),f&&(e="H"===i[0]?t(e):o(e)),e}function b({key:t,algorithm:o,noTimestamp:i,mutatePayload:n,clockTimestamp:r,expiresIn:s,notBefore:f,kid:m,typ:b,isAsync:g,additionalHeader:w,fixedPayload:v},T,k){const[O,j]=g?u(k):[];if("object"!=typeof T)throw new e(e.codes.invalidType,"The payload must be a object, a string or a buffer.");const B={alg:o,typ:b||"JWT",kid:m,...w};let S="";const x=1e3*T.iat||r||Date.now(),P={...T,...v,iat:i?void 0:Math.floor(x/1e3),exp:s?Math.floor((x+s)/1e3):void 0,nbf:f?Math.floor((x+f)/1e3):void 0};if(n&&Object.assign(T,P),S=Buffer.from(JSON.stringify(P),"utf-8").toString("base64").replace(c,p),!O){const e=Buffer.from(JSON.stringify(B),"utf-8").toString("base64").replace(c,p)+"."+S;return e+"."+("none"===o?"":d(o,t,e))}return l(t,B,(t,i)=>{if(t){const o=e.wrap(t,e.codes.keyFetchingError,"Cannot fetch key.");return O(o)}if("string"==typeof i)i=Buffer.from(i,"utf-8");else if(!(i instanceof Buffer))return O(new e(e.codes.keyFetchingError,"The key returned from the callback must be a string or a buffer containing a secret or a private key."));let n;try{const e=a(i);o?h(o,e):B.alg=o=e,i=y(i,o);const t=Buffer.from(JSON.stringify(B),"utf-8").toString("base64").replace(c,p)+"."+S;n=t+"."+d(o,i,t)}catch(e){return O(e)}O(null,n)}),j}function g(t){let{key:o,algorithm:f,noTimestamp:c,mutatePayload:p,clockTimestamp:d,expiresIn:u,notBefore:l,jti:g,aud:w,iss:v,sub:T,nonce:k,kid:O,typ:j,header:B}={clockTimestamp:0,...t};if(f&&"none"!==f&&!i.includes(f)&&!n.includes(f)&&!r.includes(f)&&!s.includes(f))throw new e(e.codes.invalidOption,`The algorithm option must be one of the following values: ${m}.`);const S=typeof o;if("none"===f){if(o)throw new e(e.codes.invalidOption,'The key option must not be provided when the algorithm option is "none".')}else if(!o||"string"!==S&&!(o instanceof Buffer)&&"function"!==S)throw new e(e.codes.invalidOption,"The key option must be a string, a buffer or a function returning the algorithm secret or private key.");if(o&&"function"!==S){const e=a(o);f?h(f,e):f=e,o=y(o,f)}if(u&&("number"!=typeof u||u<0))throw new e(e.codes.invalidOption,"The expiresIn option must be a positive number.");if(l&&("number"!=typeof l||l<0))throw new e(e.codes.invalidOption,"The notBefore option must be a positive number.");if(d&&("number"!=typeof d||d<0))throw new e(e.codes.invalidOption,"The clockTimestamp option must be a positive number.");if(g&&"string"!=typeof g)throw new e(e.codes.invalidOption,"The jti option must be a string.");if(w&&"string"!=typeof w&&!Array.isArray(w))throw new e(e.codes.invalidOption,"The aud option must be a string or an array of strings.");if(v&&"string"!=typeof v)throw new e(e.codes.invalidOption,"The iss option must be a string.");if(T&&"string"!=typeof T)throw new e(e.codes.invalidOption,"The sub option must be a string.");if(k&&"string"!=typeof k)throw new e(e.codes.invalidOption,"The nonce option must be a string.");if(O&&"string"!=typeof O)throw new e(e.codes.invalidOption,"The kid option must be a string.");if(B&&"object"!=typeof B)throw new e(e.codes.invalidOption,"The header option must be a object.");const x={jti:g,aud:w,iss:v,sub:T,nonce:k},P={key:o,algorithm:f,noTimestamp:c,mutatePayload:p,clockTimestamp:d,expiresIn:u,notBefore:l,kid:O,typ:j,isAsync:"function"===S,additionalHeader:B,fixedPayload:Object.keys(x).reduce((e,t)=>void 0!==x[t]?Object.assign(e,{[t]:x[t]}):e,{})};return b.bind(null,P)}export{g as createSigner};
