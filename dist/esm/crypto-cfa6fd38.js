import{createSign as t,createHmac as e,timingSafeEqual as r,createVerify as i,constants as n,sign as o,verify as a}from"crypto";import{derToJose as s,joseToDer as u}from"ecdsa-sig-formatter";import{TokenError as f}from"./error.js";function h(t){Object.defineProperty(this,"_next",{writable:!1,enumerable:!1,value:t}),this.done=!1}h.prototype.next=function(){if(this.done)return{done:!0};var t=this._next();return t.done&&(this.done=!0),t},"undefined"!=typeof Symbol&&(h.prototype[Symbol.iterator]=function(){return this}),h.of=function(){var t=arguments,e=t.length,r=0;return new h((function(){return r>=e?{done:!0}:{done:!1,value:t[r++]}}))},h.empty=function(){var t=new h(null);return t.done=!0,t},h.is=function(t){return t instanceof h||"object"==typeof t&&null!==t&&"function"==typeof t.next};var c=h,l="undefined"!=typeof ArrayBuffer,y="undefined"!=typeof Symbol;function p(t,e){var r,i,n,o,a;if(!t)throw new Error("obliterator/forEach: invalid iterable.");if("function"!=typeof e)throw new Error("obliterator/forEach: expecting a callback.");if(Array.isArray(t)||l&&ArrayBuffer.isView(t)||"string"==typeof t||"[object Arguments]"===t.toString())for(n=0,o=t.length;n<o;n++)e(t[n],n);else if("function"!=typeof t.forEach)if(y&&Symbol.iterator in t&&"function"!=typeof t.next&&(t=t[Symbol.iterator]()),"function"!=typeof t.next)for(i in t)t.hasOwnProperty(i)&&e(t[i],i);else for(r=t,n=0;!0!==(a=r.next()).done;)e(a.value,n),n++;else t.forEach(e)}p.forEachWithNullKeys=function(t,e){var r,i,n,o,a;if(!t)throw new Error("obliterator/forEachWithNullKeys: invalid iterable.");if("function"!=typeof e)throw new Error("obliterator/forEachWithNullKeys: expecting a callback.");if(Array.isArray(t)||l&&ArrayBuffer.isView(t)||"string"==typeof t||"[object Arguments]"===t.toString())for(n=0,o=t.length;n<o;n++)e(t[n],null);else if(t instanceof Set)t.forEach((function(t){e(t,null)}));else if("function"!=typeof t.forEach)if(y&&Symbol.iterator in t&&"function"!=typeof t.next&&(t=t[Symbol.iterator]()),"function"!=typeof t.next)for(i in t)t.hasOwnProperty(i)&&e(t[i],i);else for(r=t,n=0;!0!==(a=r.next()).done;)e(a.value,null),n++;else t.forEach(e)};var d=p,w={};!function(t){var e=Math.pow(2,8)-1,r=Math.pow(2,16)-1,i=Math.pow(2,32)-1,n=Math.pow(2,7)-1,o=Math.pow(2,15)-1,a=Math.pow(2,31)-1;t.getPointerArray=function(t){var n=t-1;return n<=e?Uint8Array:n<=r?Uint16Array:n<=i?Uint32Array:Float64Array},t.getSignedPointerArray=function(t){var e=t-1;return e<=n?Int8Array:e<=o?Int16Array:e<=a?Int32Array:Float64Array},t.getNumberType=function(t){return t===(0|t)?-1===Math.sign(t)?t<=127&&t>=-128?Int8Array:t<=32767&&t>=-32768?Int16Array:Int32Array:t<=255?Uint8Array:t<=65535?Uint16Array:Uint32Array:Float64Array};var s={Uint8Array:1,Int8Array:2,Uint16Array:3,Int16Array:4,Uint32Array:5,Int32Array:6,Float32Array:7,Float64Array:8};t.getMinimalRepresentation=function(e,r){var i,n,o,a,u,f=null,h=0;for(a=0,u=e.length;a<u;a++)o=r?r(e[a]):e[a],n=t.getNumberType(o),(i=s[n.name])>h&&(h=i,f=n);return f},t.isTypedArray=function(t){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView(t)},t.concat=function(){var t,e,r,i=0;for(t=0,r=arguments.length;t<r;t++)i+=arguments[t].length;var n=new arguments[0].constructor(i);for(t=0,e=0;t<r;t++)n.set(arguments[t],e),e+=arguments[t].length;return n},t.indices=function(e){for(var r=new(t.getPointerArray(e))(e),i=0;i<e;i++)r[i]=i;return r}}(w);var v={},b=d,m=w;function g(t){return"number"==typeof t.length?t.length:"number"==typeof t.size?t.size:void 0}v.isArrayLike=function(t){return Array.isArray(t)||m.isTypedArray(t)},v.guessLength=g,v.toArray=function(t){var e=g(t),r="number"==typeof e?new Array(e):[],i=0;return b(t,(function(t){r[i++]=t})),r},v.toArrayWithIndices=function(t){var e=g(t),r="number"==typeof e?m.getPointerArray(e):Array,i="number"==typeof e?new Array(e):[],n="number"==typeof e?new r(e):[],o=0;return b(t,(function(t){i[o]=t,n[o]=o++})),[i,n]};var S=c,A=d,E=w,k=v;function P(t,e,r){if(arguments.length<2&&(r=t,t=null,e=null),this.capacity=r,"number"!=typeof this.capacity||this.capacity<=0)throw new Error("mnemonist/lru-cache: capacity should be positive number.");var i=E.getPointerArray(r);this.forward=new i(r),this.backward=new i(r),this.K="function"==typeof t?new t(r):new Array(r),this.V="function"==typeof e?new e(r):new Array(r),this.size=0,this.head=0,this.tail=0,this.items={}}P.prototype.clear=function(){this.size=0,this.head=0,this.tail=0,this.items={}},P.prototype.splayOnTop=function(t){var e=this.head;if(this.head===t)return this;var r=this.backward[t],i=this.forward[t];return this.tail===t?this.tail=r:this.backward[i]=r,this.forward[r]=i,this.backward[e]=t,this.head=t,this.forward[t]=e,this},P.prototype.set=function(t,e){var r=this.items[t];if(void 0!==r)return this.splayOnTop(r),void(this.V[r]=e);this.size<this.capacity?r=this.size++:(r=this.tail,this.tail=this.backward[r],delete this.items[this.K[r]]),this.items[t]=r,this.K[r]=t,this.V[r]=e,this.forward[r]=this.head,this.backward[this.head]=r,this.head=r},P.prototype.setpop=function(t,e){var r=null,i=null,n=this.items[t];return void 0!==n?(this.splayOnTop(n),r=this.V[n],this.V[n]=e,{evicted:!1,key:t,value:r}):(this.size<this.capacity?n=this.size++:(n=this.tail,this.tail=this.backward[n],r=this.V[n],i=this.K[n],delete this.items[this.K[n]]),this.items[t]=n,this.K[n]=t,this.V[n]=e,this.forward[n]=this.head,this.backward[this.head]=n,this.head=n,i?{evicted:!0,key:i,value:r}:null)},P.prototype.has=function(t){return t in this.items},P.prototype.get=function(t){var e=this.items[t];if(void 0!==e)return this.splayOnTop(e),this.V[e]},P.prototype.peek=function(t){var e=this.items[t];if(void 0!==e)return this.V[e]},P.prototype.forEach=function(t,e){e=arguments.length>1?e:this;for(var r=0,i=this.size,n=this.head,o=this.K,a=this.V,s=this.forward;r<i;)t.call(e,a[n],o[n],this),n=s[n],r++},P.prototype.keys=function(){var t=0,e=this.size,r=this.head,i=this.K,n=this.forward;return new S((function(){if(t>=e)return{done:!0};var o=i[r];return++t<e&&(r=n[r]),{done:!1,value:o}}))},P.prototype.values=function(){var t=0,e=this.size,r=this.head,i=this.V,n=this.forward;return new S((function(){if(t>=e)return{done:!0};var o=i[r];return++t<e&&(r=n[r]),{done:!1,value:o}}))},P.prototype.entries=function(){var t=0,e=this.size,r=this.head,i=this.K,n=this.V,o=this.forward;return new S((function(){if(t>=e)return{done:!0};var a=i[r],s=n[r];return++t<e&&(r=o[r]),{done:!1,value:[a,s]}}))},"undefined"!=typeof Symbol&&(P.prototype[Symbol.iterator]=P.prototype.entries),P.prototype.inspect=function(){for(var t,e=new Map,r=this.entries();!(t=r.next()).done;)e.set(t.value[0],t.value[1]);return Object.defineProperty(e,"constructor",{value:P,enumerable:!1}),e},"undefined"!=typeof Symbol&&(P.prototype[Symbol.for("nodejs.util.inspect.custom")]=P.prototype.inspect),P.from=function(t,e,r,i){if(arguments.length<2){if("number"!=typeof(i=k.guessLength(t)))throw new Error("mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.")}else 2===arguments.length&&(i=e,e=null,r=null);var n=new P(e,r,i);return A(t,(function(t,e){n.set(e,t)})),n};var K=P;const j=require("asn1.js").define,{RSA_PKCS1_PSS_PADDING:I,RSA_PSS_SALTLEN_DIGEST:U,RSA_PKCS1_PADDING:R,RSA_PSS_SALTLEN_MAX_SIGN:T,RSA_PSS_SALTLEN_AUTO:V}=n;let _=o;const B=a,C="function"==typeof _,L=/[=+/]/g,N={"=":"","+":"-","/":"_"},x=/^-----BEGIN(?: (RSA|EC))? PRIVATE KEY-----/,M=new K(1e3),z=new K(1e3),D=["HS256","HS384","HS512"],O=["ES256","ES384","ES512"],$=["RS256","RS384","RS512","PS256","PS384","PS512"],G=["EdDSA"],H={"1.2.840.10045.3.1.7":{bits:"256",names:["P-256","prime256v1"]},"1.3.132.0.10":{bits:"256",names:["secp256k1"]},"1.3.132.0.34":{bits:"384",names:["P-384","secp384r1"]},"1.3.132.0.35":{bits:"512",names:["P-521","secp521r1"]}};C||(_=function(e,r,i){if(void 0===e)throw new f(f.codes.signError,"EdDSA algorithms are not supported by your Node.js version.");return t(e).update(r).sign(i)});const q=j("PrivateKey",(function(){this.seq().obj(this.key("version").int(),this.key("algorithm").seq().obj(this.key("algorithm").objid(),this.key("parameters").optional().objid()))})),Y=j("PublicKey",(function(){this.seq().obj(this.key("algorithm").seq().obj(this.key("algorithm").objid(),this.key("parameters").optional().objid()))})),F=j("ECPrivateKey",(function(){this.seq().obj(this.key("version").int(),this.key("privateKey").octstr(),this.key("parameters").explicit(0).optional().choice({namedCurve:this.objid()}))}));function W(t){return N[t]}function X(t,e,r,i){return t.set(e,[r,i]),r||i}function J(t){if(t instanceof Buffer)t=t.toString("utf-8");else if("string"!=typeof t)throw new f(f.codes.invalidKey,"The private key must be a string or a buffer.");const[e,r]=M.get(t)||[];if(e)return e;if(r)throw r;try{return X(M,t,function(t){if(t.includes("-----BEGIN PUBLIC KEY-----"))throw new f(f.codes.invalidKey,"Public keys are not supported for signing.");const e=t.trim().match(x);if(!e)return"HS256";let r,i,n;switch(e[1]){case"RSA":return"RS256";case"EC":r=F.decode(t,"pem",{label:"EC PRIVATE KEY"}),n=r.parameters.value.join(".");break;default:switch(r=q.decode(t,"pem",{label:"PRIVATE KEY"}),i=r.algorithm.algorithm.join("."),i){case"1.2.840.113549.1.1.1":return"RS256";case"1.2.840.10045.2.1":n=r.algorithm.parameters.join(".");break;case"1.3.101.112":case"1.3.101.113":return"EdDSA";default:throw new f(f.codes.invalidKey,`Unsupported PEM PCKS8 private key with OID ${i}.`)}}const o=H[n];if(!o)throw new f(f.codes.invalidKey,`Unsupported EC private key with curve ${n}.`);return`ES${o.bits}`}(t))}catch(e){throw X(M,t,null,f.wrap(e,f.codes.invalidKey,"Unsupported PEM private key."))}}function Q(t){if(!t)return"none";const[e,r]=z.get(t)||[];if(e)return e;if(r)throw r;try{if(t instanceof Buffer)t=t.toString("utf-8");else if("string"!=typeof t)throw new f(f.codes.invalidKey,"The public key must be a string or a buffer.");return X(z,t,function(t){if(t.match(x))throw new f(f.codes.invalidKey,"Private keys are not supported for verifying.");if(!t.includes("-----BEGIN PUBLIC KEY-----"))return D;const e=Y.decode(t,"pem",{label:"PUBLIC KEY"}),r=e.algorithm.algorithm.join(".");let i;switch(r){case"1.2.840.113549.1.1.1":return $;case"1.2.840.10045.2.1":i=e.algorithm.parameters.join(".");break;case"1.3.101.112":case"1.3.101.113":return["EdDSA"];default:throw new f(f.codes.invalidKey,`Unsupported PEM PCKS8 public key with OID ${r}.`)}const n=H[i];if(!n)throw new f(f.codes.invalidKey,`Unsupported EC public key with curve ${i}.`);return[`ES${n.bits}`]}(t))}catch(e){throw X(z,t,null,f.wrap(e,f.codes.invalidKey,"Unsupported PEM public key."))}}function Z(r,i,n){try{const o=r.slice(0,2),a=`sha${r.slice(2)}`;let u,f;switch(o){case"HS":u=e(a,i).update(n).digest("base64");break;case"ES":u=s(_(a,Buffer.from(n,"utf-8"),i),r).toString("base64");break;case"RS":case"PS":f={key:i,padding:R,saltLength:T},"PS"===o&&(f.padding=I,f.saltLength=U),u=t(a).update(n).sign(f).toString("base64");break;case"Ed":u=_(void 0,Buffer.from(n,"utf-8"),i).toString("base64")}return u.replace(L,W)}catch(t){throw new f(f.codes.signError,"Cannot create the signature.",{originalError:t})}}function tt(t,n,o,a){try{const s=t.slice(0,2),h=`SHA${t.slice(2)}`;if(a=Buffer.from(a,"base64"),"HS"===s)try{return r(e(h,n).update(o).digest(),a)}catch(t){return!1}else if("Ed"===s){if("function"==typeof B)return B(void 0,Buffer.from(o,"utf-8"),n,a);throw new f(f.codes.signError,"EdDSA algorithms are not supported by your Node.js version.")}const c={key:n,padding:R,saltLength:V};return"PS"===s?(c.padding=I,c.saltLength=U):"ES"===s&&(a=u(a,t)),i("RSA-"+h).update(o).verify(c,a)}catch(t){throw new f(f.codes.verifyError,"Cannot verify the signature.",{originalError:t})}}export{G as a,J as b,L as c,Q as d,O as e,W as f,Z as g,D as h,K as l,$ as r,C as u,tt as v};
